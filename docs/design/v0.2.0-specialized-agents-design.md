# v0.2.0 Specialized Agents - Design Document

**Status**: Design Phase
**Created**: 2025-11-16
**Target Release**: v0.2.0

## Executive Summary

This document outlines the architecture for four specialized blockchain agents (DeFi, NFT, Security, Analytics) that properly extend the BaseAgent abstract class while providing domain-specific functionality.

## Problem Statement

The existing framework has:
- ✅ BaseAgent abstract class with plan/execute/validate pattern
- ✅ 8 functional subagents (WalletManager, GasOptimizer, etc.)
- ✅ OrchestratorAgent for multi-agent coordination
- ❌ No specialized domain agents for DeFi, NFT, Security, Analytics

**Challenge**: Create specialized agents that:
1. Properly extend BaseAgent (implement plan/execute/validate)
2. Provide intuitive domain-specific APIs
3. Integrate with existing subagents
4. Work with OrchestratorAgent for complex workflows

## Architecture Overview

### 1. Dual-Interface Pattern

Each specialized agent will expose TWO interfaces:

#### A. BaseAgent Interface (for orchestration)
```typescript
// Required by BaseAgent abstract class
abstract plan(task: Task): Promise<TaskPlan>;
abstract execute(plan: TaskPlan): Promise<Result>;
abstract validate(result: Result): Promise<ValidationResult>;
```

#### B. Domain-Specific Methods (for direct use)
```typescript
// Example: DeFiAgent domain methods
async executeSwap(params: SwapParams): Promise<SwapResult>;
async addLiquidity(params: LiquidityParams): Promise<LiquidityResult>;
async monitorPrice(params: PriceMonitorParams): Promise<void>;
```

**How they connect**:
- Domain methods create a Task internally, then call `this.executeTask(task)`
- This triggers: plan() → execute() → validate() workflow
- Result is unwrapped and returned with domain-specific types

### 2. Task Type Registry

Standardized task types for blockchain operations:

```typescript
// DeFi Task Types
type DeFiTaskType =
  | 'defi_swap'           // Token swap on DEX
  | 'defi_add_liquidity'  // Add liquidity to pool
  | 'defi_remove_liquidity' // Remove liquidity
  | 'defi_stake'          // Stake tokens
  | 'defi_unstake';       // Unstake tokens

// NFT Task Types
type NFTTaskType =
  | 'nft_mint_erc721'     // Mint ERC721 NFT
  | 'nft_mint_erc1155'    // Mint ERC1155 NFT
  | 'nft_transfer'        // Transfer NFT
  | 'nft_batch_mint'      // Batch mint collection
  | 'nft_upload_metadata'; // Upload metadata to IPFS

// Security Task Types
type SecurityTaskType =
  | 'security_audit_contract'    // Full contract audit
  | 'security_validate_tx'       // Pre-flight validation
  | 'security_check_malicious'   // Malicious contract check
  | 'security_analyze_mev'       // MEV risk analysis
  | 'security_monitor_contract'; // Continuous monitoring

// Analytics Task Types
type AnalyticsTaskType =
  | 'analytics_get_portfolio'    // Portfolio summary
  | 'analytics_analyze_tx'       // Transaction analysis
  | 'analytics_gas_analysis'     // Gas usage analysis
  | 'analytics_price_history'    // Token price history
  | 'analytics_performance';     // Performance report
```

### 3. Agent Decomposition Strategy

Each agent implements its own task decomposition logic in the `plan()` method.

#### Example: DeFiAgent - Token Swap Decomposition

```typescript
async plan(task: Task): Promise<TaskPlan> {
  if (task.type === 'defi_swap') {
    const steps: Step[] = [
      {
        id: `${task.id}-validate-tokens`,
        action: 'validate_token_addresses',
        agent: 'security',
        params: {
          fromToken: task.params.fromToken,
          toToken: task.params.toToken
        },
        dependsOn: [],
        timeout: 5000,
      },
      {
        id: `${task.id}-get-quotes`,
        action: 'aggregate_dex_quotes',
        agent: 'defi',
        params: {
          fromToken: task.params.fromToken,
          toToken: task.params.toToken,
          amount: task.params.amount
        },
        dependsOn: [`${task.id}-validate-tokens`],
        timeout: 10000,
      },
      {
        id: `${task.id}-optimize-gas`,
        action: 'optimize_gas_price',
        agent: 'defi',
        params: { chain: task.params.chain },
        dependsOn: [`${task.id}-get-quotes`],
        timeout: 5000,
      },
      {
        id: `${task.id}-simulate`,
        action: 'simulate_swap_transaction',
        agent: 'security',
        params: {
          transaction: '...' // Built in previous step
        },
        dependsOn: [`${task.id}-optimize-gas`],
        timeout: 10000,
      },
      {
        id: `${task.id}-execute`,
        action: 'execute_swap_transaction',
        agent: 'defi',
        params: {
          signedTx: '...'
        },
        dependsOn: [`${task.id}-simulate`],
        timeout: 60000,
      },
    ];

    return {
      id: `plan-${task.id}`,
      taskId: task.id,
      steps,
      dependencies: this.buildDependencies(steps),
      estimatedTime: steps.reduce((sum, s) => sum + s.timeout, 0),
      requiredResources: [
        { type: 'rpc', name: 'ethereum-rpc', required: true },
        { type: 'wallet', name: 'signer', required: true },
      ],
      fallbackStrategies: [],
      createdAt: new Date(),
    };
  }

  throw new Error(`Unknown task type: ${task.type}`);
}
```

### 4. Execution Pattern

The `execute()` method runs the plan steps:

```typescript
async execute(plan: TaskPlan): Promise<Result> {
  const stepResults = new Map<string, Result>();

  // Execute steps in dependency order
  for (const step of this.topologicalSort(plan.steps)) {
    try {
      const result = await this.executeStep(step, stepResults);
      stepResults.set(step.id, result);

      if (!result.success) {
        return {
          success: false,
          error: `Step ${step.action} failed: ${result.error}`,
          metadata: { failedStep: step.id },
        };
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
        metadata: { failedStep: step.id },
      };
    }
  }

  // Aggregate final result
  const finalStepId = plan.steps[plan.steps.length - 1].id;
  return stepResults.get(finalStepId) || { success: false, error: 'No result' };
}

private async executeStep(step: Step, previousResults: Map<string, Result>): Promise<Result> {
  // Handle step based on action
  switch (step.action) {
    case 'validate_token_addresses':
      return await this.validateTokens(step.params);

    case 'aggregate_dex_quotes':
      return await this.aggregateQuotes(step.params);

    case 'optimize_gas_price':
      return await this.optimizeGas(step.params);

    case 'simulate_swap_transaction':
      return await this.simulateTransaction(step.params, previousResults);

    case 'execute_swap_transaction':
      return await this.executeTransaction(step.params, previousResults);

    default:
      throw new Error(`Unknown action: ${step.action}`);
  }
}
```

### 5. Validation Pattern

The `validate()` method ensures result integrity:

```typescript
async validate(result: Result): Promise<ValidationResult> {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Basic validation
  if (!result.success) {
    if (!result.error) {
      errors.push('Failed result must have error message');
    }
  }

  // Success validation
  if (result.success) {
    if (!result.data) {
      errors.push('Successful result must have data');
    }

    // Domain-specific validation
    if (result.data) {
      const data = result.data as SwapResult;

      if (!data.txHash) {
        errors.push('Swap result missing transaction hash');
      }

      if (!data.amountOut || parseFloat(data.amountOut) <= 0) {
        errors.push('Swap result has invalid output amount');
      }

      // Check slippage
      const expectedAmount = parseFloat(data.expectedAmountOut || '0');
      const actualAmount = parseFloat(data.amountOut || '0');
      const slippage = ((expectedAmount - actualAmount) / expectedAmount) * 100;

      if (slippage > 5) {
        warnings.push(`High slippage detected: ${slippage.toFixed(2)}%`);
      }
    }
  }

  return {
    valid: errors.length === 0,
    errors: errors.length > 0 ? errors : undefined,
    warnings: warnings.length > 0 ? warnings : undefined,
  };
}
```

### 6. Subagent Integration

Specialized agents use existing subagents for low-level operations:

```typescript
export class DeFiAgent extends BaseAgent {
  private txBuilder: TransactionBuilder;
  private gasOptimizer: GasOptimizer;
  private simulator: TransactionSimulator;
  private priceOracle: PriceOracle;
  private walletManager: WalletManager;

  constructor(config: AgentConfig,
              providers: { ethereum: JsonRpcProvider, solana: Connection }) {
    super(config);

    // Initialize subagents
    this.txBuilder = new TransactionBuilder(providers.ethereum);
    this.gasOptimizer = new GasOptimizer();
    this.simulator = new TransactionSimulator(providers.ethereum);
    this.priceOracle = new PriceOracle(providers.ethereum);
    this.walletManager = new WalletManager();
  }

  private async optimizeGas(params: unknown): Promise<Result> {
    try {
      const strategy = await this.gasOptimizer.analyzeGasMarket('ethereum');
      return {
        success: true,
        data: {
          maxFeePerGas: strategy.maxFeePerGas,
          maxPriorityFeePerGas: strategy.maxPriorityFeePerGas,
        },
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }
}
```

## Implementation Plan

### Phase 1: Foundation (2-3 hours)
- [ ] Create base types for specialized agents
- [ ] Implement TaskTypeRegistry with all task types
- [ ] Create BaseSpecializedAgent helper class with common patterns
- [ ] Add comprehensive tests for base patterns

### Phase 2: DeFiAgent (3-4 hours)
- [ ] Implement DeFiAgent extending BaseAgent
- [ ] Add task decomposition for: swap, add_liquidity, remove_liquidity
- [ ] Integrate: TransactionBuilder, GasOptimizer, TransactionSimulator, PriceOracle
- [ ] Add domain-specific methods: executeSwap(), addLiquidity(), etc.
- [ ] Write unit tests (30+ tests)
- [ ] Write integration tests

### Phase 3: NFTAgent (3-4 hours)
- [ ] Implement NFTAgent extending BaseAgent
- [ ] Add task decomposition for: mint_erc721, mint_erc1155, transfer, batch_mint
- [ ] Integrate: TransactionBuilder, ContractAnalyzer, WalletManager
- [ ] Add IPFS metadata upload support
- [ ] Add domain-specific methods: mintERC721(), mintERC1155(), etc.
- [ ] Write unit tests (30+ tests)
- [ ] Write integration tests

### Phase 4: SecurityAgent (2-3 hours)
- [ ] Implement SecurityAgent extending BaseAgent
- [ ] Add task decomposition for: audit, validate_tx, check_malicious, mev_analysis
- [ ] Integrate: ContractAnalyzer, TransactionSimulator
- [ ] Add domain-specific methods: auditContract(), validateTransaction(), etc.
- [ ] Write unit tests (25+ tests)
- [ ] Write integration tests

### Phase 5: AnalyticsAgent (2-3 hours)
- [ ] Implement AnalyticsAgent extending BaseAgent
- [ ] Add task decomposition for: portfolio, tx_analysis, gas_analysis, price_history
- [ ] Integrate: PriceOracle
- [ ] Add domain-specific methods: getPortfolio(), analyzeTransactions(), etc.
- [ ] Write unit tests (25+ tests)
- [ ] Write integration tests

### Phase 6: Integration & Examples (2-3 hours)
- [ ] Update OrchestratorAgent to register specialized agents
- [ ] Create example: 01-defi-swap-example.ts
- [ ] Create example: 02-nft-minting-example.ts
- [ ] Create example: 03-security-audit-example.ts
- [ ] Create example: 04-portfolio-analytics-example.ts
- [ ] Create tutorial: specialized-agents-guide.md
- [ ] Update CHANGELOG for v0.2.0

### Phase 7: Validation & Release (1-2 hours)
- [ ] Run full test suite (target: 600+ tests, 80%+ coverage)
- [ ] Run typecheck (must pass with 0 errors)
- [ ] Run lint (resolve critical issues)
- [ ] Update README with v0.2.0 features
- [ ] Create v0.2.0 release commit
- [ ] Push to remote branch

**Total Estimated Time**: 15-22 hours

## Type Definitions

### Domain-Specific Param Types

```typescript
// DeFi
export interface SwapParams {
  fromToken: string;
  toToken: string;
  amount: string;
  chain: 'ethereum' | 'polygon' | 'arbitrum' | 'optimism';
  slippage?: number; // percentage (default: 0.5)
  recipient?: string;
  deadline?: number; // Unix timestamp
}

export interface LiquidityParams {
  poolAddress: string;
  token0: string;
  token1: string;
  amount0: string;
  amount1: string;
  chain: 'ethereum' | 'polygon' | 'arbitrum';
  slippage?: number;
}

// NFT
export interface MintERC721Params {
  contract: string;
  recipient: string;
  metadata: NFTMetadata;
  chain: 'ethereum' | 'polygon' | 'solana';
}

export interface NFTMetadata {
  name: string;
  description: string;
  image: string; // URL or data URI
  external_url?: string;
  attributes?: Array<{
    trait_type: string;
    value: string | number;
  }>;
}

// Security
export interface AuditParams {
  address: string;
  chain: 'ethereum' | 'solana';
  includeSourceCode?: boolean;
  deepAnalysis?: boolean;
}

// Analytics
export interface PortfolioParams {
  address: string;
  chains: Array<'ethereum' | 'polygon' | 'solana'>;
  includeNFTs?: boolean;
}
```

### Domain-Specific Result Types

```typescript
export interface SwapResult {
  success: boolean;
  txHash?: string;
  amountOut?: string;
  expectedAmountOut?: string;
  slippage?: number;
  gasUsed?: string;
  error?: string;
}

export interface MintResult {
  success: boolean;
  txHash?: string;
  tokenId?: string;
  metadataUri?: string;
  contractAddress?: string;
  error?: string;
}

export interface AuditResult {
  address: string;
  riskLevel: 'minimal' | 'low' | 'medium' | 'high' | 'critical';
  findings: VulnerabilityFinding[];
  score: number; // 0-100
  recommendations: string[];
}

export interface PortfolioSummary {
  totalValueUSD: number;
  assets: Array<{
    token: string;
    balance: string;
    priceUSD: number;
    valueUSD: number;
    chain: string;
  }>;
  nfts?: Array<{
    contract: string;
    tokenId: string;
    chain: string;
  }>;
}
```

## Error Handling Strategy

### 1. Task-Level Errors
- Invalid task type → throw in plan()
- Missing required params → throw in plan()
- Resource unavailable → return Result with success: false

### 2. Step-Level Errors
- Step execution fails → return Result with error, stop plan execution
- Timeout exceeded → cancel step, return timeout error
- Dependency failed → skip step, propagate error

### 3. Validation Errors
- Validation fails → mark Result as invalid, add to errors array
- Warnings → add to warnings array, Result still valid

### 4. Domain Method Errors
- Domain method wraps errors in Result type
- Unwraps and re-throws if needed for developer ergonomics

## Testing Strategy

### Unit Tests
- Each agent: 25-30 tests minimum
- Test plan() for all task types
- Test execute() success/failure paths
- Test validate() with various result shapes
- Test domain methods
- Mock all subagents

### Integration Tests
- Test agent with real subagents (mocked blockchain)
- Test multi-step task execution
- Test error propagation
- Test timeout handling
- Test concurrent task execution

### E2E Tests (Future)
- Test with local Hardhat node (Ethereum)
- Test with Solana test validator
- Test actual swaps, mints, audits on testnets

## Migration Guide

### For Existing Code

**Before** (direct subagent use):
```typescript
const txBuilder = new TransactionBuilder(provider);
const gasOptimizer = new GasOptimizer();
const simulator = new TransactionSimulator(provider);

// Build transaction
const tx = await txBuilder.buildERC20Transfer(...);

// Optimize gas
const gasPrice = await gasOptimizer.analyzeGasMarket('ethereum');

// Simulate
const simResult = await simulator.simulate(...);

// Execute
...
```

**After** (agent-based):
```typescript
const defiAgent = new DeFiAgent(config, { ethereum: provider });

// One call handles everything
const result = await defiAgent.executeSwap({
  fromToken: 'ETH',
  toToken: 'USDC',
  amount: '1.0',
  chain: 'ethereum',
  slippage: 0.5,
});

if (result.success) {
  console.log('Swap executed:', result.txHash);
} else {
  console.error('Swap failed:', result.error);
}
```

### For Orchestrator Use

```typescript
const orchestrator = new OrchestratorAgent(config);

// Register specialized agents
orchestrator.registerAgent('defi', defiAgent);
orchestrator.registerAgent('nft', nftAgent);
orchestrator.registerAgent('security', securityAgent);

// Execute complex multi-agent task
const task: Task = {
  id: 'swap-and-mint',
  type: 'complex_workflow',
  params: {
    steps: ['defi_swap', 'nft_mint'],
  },
  priority: 1,
};

const result = await orchestrator.executeTask(task);
```

## Success Criteria

- ✅ All 4 specialized agents properly extend BaseAgent
- ✅ All agents implement plan/execute/validate correctly
- ✅ All agents provide intuitive domain-specific APIs
- ✅ 600+ total tests passing (current: 471)
- ✅ 80%+ test coverage maintained
- ✅ TypeScript compiles with 0 errors
- ✅ Documentation complete (4 examples, 1 tutorial)
- ✅ Integration with OrchestratorAgent verified

## Risks & Mitigation

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Task decomposition too complex | High | Medium | Start simple, iterate |
| Type safety issues with params | Medium | Low | Use Zod validation |
| Subagent integration bugs | High | Medium | Comprehensive mocking in tests |
| Performance issues | Low | Low | Profile critical paths |
| API inconsistency | Medium | Medium | Review API design before coding |

## Open Questions

1. **Should domain methods accept Task objects OR domain-specific params?**
   - Decision: Domain-specific params for better DX
   - Wrap internally into Task for executeTask()

2. **How to handle cross-chain operations?**
   - Decision: Each agent supports multiple chains
   - Chain specified in task params

3. **Should agents be singletons or instantiated per-operation?**
   - Decision: Long-lived instances with internal state management
   - Create once, reuse many times

4. **How to handle websocket subscriptions for monitoring?**
   - Decision: Phase 2 (v0.3.0)
   - For now, polling-based monitoring

## References

- BaseAgent: `src/agents/BaseAgent.ts`
- OrchestratorAgent: `src/agents/OrchestratorAgent.ts`
- TaskPlanner: `src/agents/planning.ts`
- Agent Types: `src/types/agent.ts`
- Existing Tests: `tests/unit/agents/`

---

**Next Steps**: Review this design, get approval, then proceed with Phase 1 implementation.
